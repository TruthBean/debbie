/**
 * Copyright (c) 2024 TruthBean(Rogar·Q)
 * Debbie is licensed under Mulan PSL v2.
 * You can use this software according to the terms and conditions of the Mulan PSL v2.
 * You may obtain a copy of Mulan PSL v2 at:
 * http://license.coscl.org.cn/MulanPSL2
 * THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT, MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
 * See the Mulan PSL v2 for more details.
 */
package com.truthbean.debbie.jdbc.repository;

import com.truthbean.Logger;
import com.truthbean.LoggerFactory;
import com.truthbean.debbie.jdbc.column.ColumnInfo;
import com.truthbean.debbie.jdbc.column.FStartColumnNameTransformer;
import com.truthbean.debbie.jdbc.column.JdbcColumnResolver;
import com.truthbean.debbie.jdbc.column.type.ColumnTypeHandler;
import com.truthbean.debbie.jdbc.datasource.DataSourceDriverName;
import com.truthbean.debbie.jdbc.transaction.TransactionException;
import com.truthbean.debbie.jdbc.transaction.TransactionInfo;
import com.truthbean.debbie.jdbc.util.JdbcUtils;
import com.truthbean.debbie.reflection.ReflectionHelper;
import com.truthbean.debbie.util.ObjectStringUtils;

import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.*;

/**
 * handle repository of curd
 *
 * @author TruthBean
 * @since 0.0.1
 * Created on 2018-03-14 11:53
 */
public class RepositoryHandler {
    private static final Logger LOGGER = LoggerFactory.getLogger(RepositoryHandler.class);

    public final int[] batch(Logger logger, final TransactionInfo transaction, final String sql, final Object[][] args) {
        loggerSqlAndParameters(logger, sql, args);

        PreparedStatement preparedStatement = null;
        int[] rows;
        try {
            transaction.setUsing(true);
            var connection = transaction.getConnection();
            if (transaction.isClosed()) {
                return new int[0];
            }
            preparedStatement = connection.prepareStatement(sql);
            int count = args == null || args.length == 0 ? 0 : args.length;
            DataSourceDriverName driverName = transaction.getDriverName();
            for (int j = 0; j < count; j++) {
                for (int i = 0; i < args[j].length; i++) {
                    ColumnTypeHandler.setSqlArgValue(driverName, preparedStatement, i + 1, args[j][i]);
                }
                //jdbc自带的批量操作方法，存储sql操作集
                preparedStatement.addBatch();
            }
            //执行sql操作集
            rows = preparedStatement.executeBatch();
        } catch (SQLException ex) {
            LOGGER.error("", ex);
            throw new TransactionException(ex);
        } finally {
            transaction.setUsing(false);
            JdbcUtils.close(null, preparedStatement);
        }
        return rows;
    }

    public final boolean execute(Logger logger, final TransactionInfo transaction, final String sql) {
        loggerSqlAndParameters(logger, sql, null);

        PreparedStatement preparedStatement = null;
        boolean execute;
        try {
            transaction.setUsing(true);
            var connection = transaction.getConnection();
            if (transaction.isClosed()) {
                return false;
            }
            preparedStatement = connection.prepareStatement(sql);
            execute = preparedStatement.execute(sql);
        } catch (SQLException ex) {
            LOGGER.error("", ex);
            throw new TransactionException(ex);
        } finally {
            transaction.setUsing(false);
            JdbcUtils.close(null, preparedStatement);
        }
        return execute;
    }

    @SuppressWarnings("unchecked")
    public final <K> K insert(Logger logger, final TransactionInfo transaction, final String sql, final boolean generatedKeys,
                              final Class<K> keyClass, final Object... args) {

        loggerSqlAndParameters(logger, sql, args);

        K id = null;
        PreparedStatement preparedStatement = null;
        ResultSet resultSet = null;
        try {
            int autoGeneratedKeys;
            if (generatedKeys) {
                // 获取自动生成的键
                autoGeneratedKeys = Statement.RETURN_GENERATED_KEYS;
            } else {
                autoGeneratedKeys = Statement.NO_GENERATED_KEYS;
            }
            transaction.setUsing(true);
            var connection = transaction.getConnection();
            if (transaction.isClosed()) {
                return (K) ReflectionHelper.getDefaultValue(keyClass);
            }
            preparedStatement = connection.prepareStatement(sql, autoGeneratedKeys);
            if (args != null && args.length > 0) {
                DataSourceDriverName driverName = transaction.getDriverName();
                for (int i = 0; i < args.length; i++) {
                    ColumnTypeHandler.setSqlArgValue(driverName, preparedStatement, i + 1, args[i]);
                }
            }
            int row = preparedStatement.executeUpdate();
            LOGGER.debug(row + " row data has been inserted");
            if (generatedKeys) {
                resultSet = preparedStatement.getGeneratedKeys();
                if (resultSet.next()) {
                    id = ColumnTypeHandler.getColumnValue(resultSet, 1, keyClass.getName());
                }
            }
        } catch (SQLException | ClassNotFoundException ex) {
            throw new TransactionException(ex);
        } finally {
            transaction.setUsing(false);
            JdbcUtils.close(resultSet, preparedStatement);
        }
        return id;
    }

    public final int update(Logger logger, final TransactionInfo transaction, final String sql, final Object... args) {
        loggerSqlAndParameters(logger, sql, args);

        PreparedStatement preparedStatement = null;
        int rows;
        try {
            transaction.setUsing(true);
            var connection = transaction.getConnection();
            if (transaction.isClosed()) {
                return 0;
            }
            preparedStatement = connection.prepareStatement(sql);
            int count = args == null ? 0 : args.length;
            DataSourceDriverName driverName = transaction.getDriverName();
            for (int i = 0; i < count; i++) {
                ColumnTypeHandler.setSqlArgValue(driverName, preparedStatement, i + 1, args[i]);
            }
            rows = preparedStatement.executeUpdate();
        } catch (SQLException ex) {
            LOGGER.error("", ex);
            throw new TransactionException(ex);
        } finally {
            transaction.setUsing(false);
            JdbcUtils.close(null, preparedStatement);
        }
        return rows;
    }

    public final List<List<ColumnInfo>> query(Logger logger, final TransactionInfo transaction, final String sql, final Object... args) {
        loggerSqlAndParameters(logger, sql, args);

        List<List<ColumnInfo>> list = new ArrayList<>();

        PreparedStatement preparedStatement = null;
        ResultSet resultSet = null;

        try {
            transaction.setUsing(true);
            var connection = transaction.getConnection();
            if (transaction.isClosed()) {
                return new ArrayList<>();
            }
            if (connection == null) {
                throw new TransactionException("connection is null");
            }
            preparedStatement = connection.prepareStatement(sql);
            if (args != null && args.length > 0) {
                DataSourceDriverName driverName = transaction.getDriverName();
                for (int e = 0; e < args.length; ++e) {
                    ColumnTypeHandler.setSqlArgValue(driverName, preparedStatement, e + 1, args[e]);
                }
            }
            resultSet = preparedStatement.executeQuery();
            var tmp = JdbcColumnResolver.resolveResultSetValue(resultSet, new FStartColumnNameTransformer());
            if (!tmp.isEmpty()) {
                list.addAll(tmp);
            }
        } catch (SQLException e) {
            LOGGER.error("", e);
            throw new TransactionException(e);
        } finally {
            transaction.setUsing(false);
            JdbcUtils.close(resultSet, preparedStatement);
        }
        return list;
    }

    public final List<ColumnInfo> querySingle(Logger logger, final TransactionInfo transaction, final String sql, final Object... args) {
        loggerSqlAndParameters(logger, sql, args);

        List<ColumnInfo> list = new ArrayList<>();

        PreparedStatement preparedStatement = null;
        ResultSet resultSet = null;

        try {
            transaction.setUsing(true);
            var connection = transaction.getConnection();
            if (transaction.isClosed()) {
                return new ArrayList<>();
            }
            if (connection == null) {
                throw new TransactionException("connection is null");
            }
            preparedStatement = connection.prepareStatement(sql);
            if (args != null) {
                DataSourceDriverName driverName = transaction.getDriverName();
                for (int e = 0; e < args.length; ++e) {
                    ColumnTypeHandler.setSqlArgValue(driverName, preparedStatement, e + 1, args[e]);
                }
            }
            resultSet = preparedStatement.executeQuery();
            var tmp = JdbcColumnResolver.resolveResultSetValue(resultSet, new FStartColumnNameTransformer());
            if (!tmp.isEmpty()) {
                list.addAll(tmp.get(0));
            }
        } catch (SQLException e) {
            LOGGER.error("", e);
            throw new TransactionException(e);
        } finally {
            transaction.setUsing(false);
            JdbcUtils.close(resultSet, preparedStatement);
        }
        return list;
    }

    public List<Map<String, Object>> queryMap(Logger logger, TransactionInfo transaction, String selectSql, Object... args) {
        List<List<ColumnInfo>> selectResult = query(logger, transaction, selectSql, args);
        List<Map<String, Object>> result = new ArrayList<>();
        Map<String, Object> map;
        for (List<ColumnInfo> columnInfos : selectResult) {
            map = new HashMap<>();
            for (ColumnInfo columnInfo : columnInfos) {
                map.put(columnInfo.getColumn(), columnInfo.getValue());
            }
            result.add(map);
        }
        return result;
    }

    public List<ColumnInfo> queryOne(Logger logger, TransactionInfo transaction, String selectSql, Object... args) {
        List<List<ColumnInfo>> selectResult = query(logger, transaction, selectSql, args);
        if (selectResult.isEmpty()) {
            return new ArrayList<>();
        }
        if (selectResult.size() == 1) {
            return selectResult.get(0);
        } else {
            throw new MoreRowException("Expect one row, but it has" + selectResult.size() + " rows.");
        }
    }

    public ColumnInfo querySingleOne(Logger logger, TransactionInfo transaction, String selectSql, Object... args) {
        List<ColumnInfo> selectResult = querySingle(logger, transaction, selectSql, args);
        if (selectResult.isEmpty()) {
            return null;
        }
        if (selectResult.size() == 1) {
            return selectResult.get(0);
        } else {
            throw new MoreRowException("Expect one row, but it has" + selectResult.size() + " rows.");
        }
    }

    private void loggerSqlAndParameters(Logger logger, String sql, Object[][] args) {
        if (logger.isDebugEnabled()) {
            logger.debug("Preparing >>> " + sql);
            logger.debug("Parameters >>> " + Arrays.deepToString(args));
        }
    }

    private void loggerSqlAndParameters(Logger logger, String sql, Object[] args) {
        if (logger.isDebugEnabled()) {
            logger.debug("Preparing >>> " + sql);
            logger.debug("Parameters >>> " + ObjectStringUtils.getParameterValueString(args));
        }
    }
}
